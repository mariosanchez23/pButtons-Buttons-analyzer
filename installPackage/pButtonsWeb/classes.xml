<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25" zv="Cache for UNIX (Apple Mac OS X for x86-64) 2017.3 (Build 502U)" ts="2017-02-27 15:55:07">
<Class name="pButtons.Server">
<Super>%CSP.REST</Super>
<TimeChanged>64341,45553.485837</TimeChanged>
<TimeCreated>64295,50846.46682</TimeCreated>

<XData name="UrlMap">
<Data><![CDATA[
<Routes>
	<Route Url="/directoryList/:directoryId" Method="GET" Call="getDirectoryList"/>
	<Route Url="/deleteFile/:directory/:filename" Method="GET" Call="doDeleteFile"/>
	<Route Url="/uploadFile/" Method="POST" Call="uploadFile"/>
		
</Routes>
]]></Data>
</XData>

<Parameter name="UseSession">
<Description>
This parameter controls the CSP session support. By default the CSP session will be
ended after each request in accordance with the spirit of REST. However this CAN be
overridden by the user. To use a session, it's necessary to manage the CSPSESSION cookie.
Browsers do this automatically but command line tools such as CURL require the setting of
options.</Description>
<Type>Integer</Type>
<Default>1</Default>
</Parameter>

<Method name="getDirectoryList">
<ClassMethod>1</ClassMethod>
<FormalSpec>directoryName</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 
	#dim ReturnStatus as %Status
	set ReturnStatus = $$$OK
	set baseDirectory= ^PowerpButtons("UploadDirectory")
	set directory=##class(%File).NormalizeDirectory(directoryName,baseDirectory)
	
	Set rset = ##class(%ResultSet).%New("%File:FileSet")
	 // Execute the query
	Set sc = rset.Execute(directory,"*.html;*.HTML;*.txt;*.")
	
	set jsonFiles = []
	While (rset.Next()) {
		set type=$PIECE(rset.GetDataByName("ItemName"),"_",1)
		set jsonFile = {"name":(rset.GetDataByName("ItemName")),"size":(rset.GetDataByName("Size")),"type":(type)}
		do jsonFiles.%Push(jsonFile)
	}    
	do rset.Close()
	
	write {"files":(jsonFiles)}.%ToJSON()
	
	
	quit ReturnStatus
]]></Implementation>
</Method>

<Method name="doDeleteFile">
<ClassMethod>1</ClassMethod>
<FormalSpec>directoryname,filename</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim ReturnStatus as %Status
	set baseDirectory= ^PowerpButtons("UploadDirectory")
	set directory=##class(%File).NormalizeDirectory(directoryname,baseDirectory)
	set file=##class(%File).NormalizeFilename(filename,directory)
	set directoryMetrics=##class(%File).NormalizeDirectory(filename_".sections",directory)
	
	set sc1=##class(%File).Delete(file)
	set sc2=##class(%File).RemoveDirectoryTree(directoryMetrics)
	
	// check if there is any file to delete completely the directory
    // It's a good way to clean ;-)
    
    Set rset = ##class(%ResultSet).%New("%File:FileSet")
	Set sc = rset.Execute(directory)
	if (rset.Next() = 0) { // There is nothing so clean whole directory
		set sc3=##class(%File).RemoveDirectoryTree(directory)
	}    
	do rset.Close()
	
	quit ReturnStatus
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// Upload files methods

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// 

]]></Content>
</UDLText>

<Method name="uploadFile">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set directory=$G(%request.Data("directory",1))
	set output = {"error":"Empty File"}
	
	if ($data(%request.MimeData("file",1)))
	{
		set file=%request.MimeData("file",1)
		if (directory'="")
		{
			s phisycalDirectory = ..CheckAndCreateUniqueDirectory(.directory)
			s fileName=$ZCONVERT(file.FileName,"U")
			set uploadedFile = ##class(%File).NormalizeFilename(fileName,phisycalDirectory)
			set f=##class(%Stream.FileBinary).%New()
			do f.LinkToFile(uploadedFile)
			s sc=f.CopyFromAndSave(file)
			
			set sc=##class(pButtons.Utilities).unzipFile(.uploadedFile)
			set sc=##class(pButtons.Utilities).checkFileType(.uploadedFile)
			set previewHTML=##class(pButtons.Utilities).parseHTML(uploadedFile)
			
			set finalFileName=##class(%File).GetFilename(uploadedFile)
			// return output file and properties
			set output = {"name":(finalFileName),"previewPage":(previewHTML_"?file=uploaded/"_directory_"/"_finalFileName)}
			
		} else{
			set output = {"error":"Empty directory"}
		}
	}
	
	write output.%ToJSON()
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="CheckAndCreateUniqueDirectory">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&directory:%String]]></FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set originalDirectory = directory
	s i=1
	set baseDirectory= ^PowerpButtons("UploadDirectory")
	
	while ('##class(%File).CreateNewDir(baseDirectory,directory) || i>100){
		set directory = originalDirectory_"("_i_")" ; if the directory exist add some number
		s i=i+1
	}
	return ##class(%File).NormalizeDirectory(directory,baseDirectory)
]]></Implementation>
</Method>
</Class>


<Class name="pButtons.Utilities">
<Abstract>1</Abstract>
<Super>%RegisteredObject</Super>
<TimeChanged>64341,56591.473688</TimeChanged>
<TimeCreated>64295,50844.887095</TimeCreated>

<UDLText name="T">
<Content><![CDATA[
// PArse the html and returns the preview HTML page to visualize

]]></Content>
</UDLText>

<Method name="parseHTML">
<ClassMethod>1</ClassMethod>
<FormalSpec>pFile</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set justFileName=##class(%File).GetFilename(pFile)
		
	set fileType=$PIECE(justFileName,"_",1)
	if (fileType="pButtons"){
		do ..parseHTMLpButtons(pFile)
		return "pButtons.html"
	}elseif (fileType="Buttons"){
		do ..parseHTMLButtons(pFile)
		return "pButtons.html"
	}
	return "console.html"
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// Check the type of file to parse as pButtons or as Buttons

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// and rename the file adding the type

]]></Content>
</UDLText>

<Method name="checkFileType">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pFile]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	try {
		Set data=##class(%Stream.FileCharacter).%New()
		$$$THROWONERROR(tSC, data.LinkToFile(pFile))
		
		set justFileName=##class(%File).GetFilename(pFile)
		set justDirectory=##class(%File).GetDirectory(pFile)
		
		// Read first 
		do data.Rewind()
		set firstLines=data.Read(100)
		
		if ($FIND(firstLines,"Diagnostic Log")){
			set type = "Buttons_"
		}elseif ($FIND(firstLines,"Performance Data Report")) {
		 	set type =  "pButtons_"
		}
		else {
			// change .log files to txt to be able to parse correctly from iframes
			set type = "Other_"
			set justFileName=$ZSTRIP(justFileName,"*P")_".txt"
		}
		// This is needed to be able to rename the file in Windows. s
		kill data
		
		s finalName=##class(%File).NormalizeFilename(type_justFileName,justDirectory)
		set sc=##class(%File).Rename(pFile,finalName)
		set:sc=1 pFile=finalName
	
	} catch ex {
		set ret = ex.AsStatus()
		write !,"<ERROR> parseHTML: "_$system.Status.GetOneErrorText(ret)
	}
	quit $$$OK
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
//  ---------------------- parse pButtons functions  ----------------------

]]></Content>
</UDLText>

<Method name="parseHTMLpButtons">
<Description>
main parse function to parse pButtons
</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pFile</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set directory = pFile_".sections"
	set ret = $$$OK
	try {
		Set stream=##class(%Stream.FileCharacter).%New()
		$$$THROWONERROR(tSC, stream.LinkToFile(pFile))
		set sc=##class(%File).CreateDirectory(directory)
		if sc {
			do ..writepButtonsSectionsToFile(stream,directory)
		}else{
			write !,"ERROR:can't create directory "_directory_"\n"
		}
		
	} catch ex {
		set ret = ex.AsStatus()
		write !,"<ERROR> parseHTML: "_$system.Status.GetOneErrorText(ret)
	}
	quit ret
]]></Implementation>
</Method>

<Method name="writepButtonsSectionsToFile">
<ClassMethod>1</ClassMethod>
<FormalSpec>data:%Stream.FileCharacter,directory</FormalSpec>
<Implementation><![CDATA[
	set startSearch=1
	set listSections=""
	while ('data.AtEnd){
		set sectionPosition=data.FindAt(startSearch,"<div id=")
		quit:sectionPosition=-1 ; no more sections found
		
		set sc = data.MoveTo( sectionPosition )
		set sectionLine = data.ReadLine()
		set startSearch=sectionPosition+$L(sectionLine)
		
		// Parse section with format:
		//<div id="Configuration"></div>Configuration</font></b></p><pre>
		set section = $ZSTRIP($P($p(sectionLine,"id=",2),"></div>",1),"*P") 
		
		// open file to write section
		set fileName = ##class(%File).NormalizeFilename(section_".txt",directory)
		Set fileStream = ##class(%Stream.FileCharacter).%New()
		set fileStream.Filename=fileName
		// search end of section which always start with <pre> finish with </pre>
		set line = $P(sectionLine,"<pre>",2)
		//set line=data.ReadLine()
	
	
		// Improvement. Apply regex to remove html tags
		// set matcher=##class(%Regex.Matcher).%New("(<([^>]+)>)")
		//set matcher.Text=t
		//set t=matcher.ReplaceAll("") 
	
	
		// sections like SS and cstat are multisections
		// Improvement, parse specifically each section
		if (section="SS") || (section="cstatc1") || (section="cstatD"){
			set endSection="</pre><p"}
		else {
			set endSection="</pre>"
			}
		
		while ( '$FIND(line,endSection) || data.AtEnd ){
			do fileStream.WriteLine(line)
			set line = data.ReadLine()
			set startSearch=startSearch+$L(line)
		}
		do fileStream.%Save()
		
		// Parse sard data to get graphs
		if (section="sard") { 
			job ..parseSard(fileName)
		}
		
		set listSections=listSections_","_section
		// Write some output with progress
		//set procesed = $NORMALIZE(startSearch*100/data.Size,2)
		//set ^pButtonsUpload(fileName,listSections)="Section "_ section_" exported. Procesed: "_ procesed _"%"
	}
	
	// save the sections.txt file with a list of all the processed sections
	set fileName = ##class(%File).NormalizeFilename("sections.txt",directory)
	Set fileStream = ##class(%Stream.FileCharacter).%New()
	set fileStream.Filename=fileName
	do fileStream.WriteLine(listSections_",") //Added an empty line to parse easier 
	do fileStream.%Save()
	
	quit
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
//  ---------------------- parse sard functions  ----------------------

]]></Content>
</UDLText>

<Method name="parseSard">
<Description>
parse sard info into multiple files</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>filename</FormalSpec>
<Implementation><![CDATA[
	try {
		Set stream=##class(%Stream.FileCharacter).%New()
		$$$THROWONERROR(tSC, stream.LinkToFile(filename))
		set directory=filename_".sard"
		set sc=##class(%File).CreateDirectory(directory)
		
		if sc {
			do ..writeDevicesToFile(stream,directory)
		}else{
			write !,"ERROR:can't create directory "_directory_"\n"
		}
		
	} catch ex {
		set ret = ex.AsStatus()
		write !,"<ERROR> parseSard: "_$system.Status.GetOneErrorText(ret)
	}
	quit
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// Creates a file for every device in sard.

]]></Content>
</UDLText>

<Method name="writeDevicesToFile">
<ClassMethod>1</ClassMethod>
<FormalSpec>data:%Stream.FileCharacter,directory</FormalSpec>
<Implementation><![CDATA[
	// First lines like
	// Linux 2.6.32-131.0.15.el6.x86_64 (c0lx0009.sacyl.es) 	11/11/16 	_x86_64_	(24 CPU)
	// 11:24:00          DEV       tps  rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util
	// 11:24:10     dev65-64      3,50      0,00    110,51     31,54      
	
	set sc = data.MoveTo(1)
	do data.ReadLine()
	do data.ReadLine() // Jump one line
	set headerLine = data.ReadLine()	
	// loop through file searching for device Names and creating the empty files
	// It is better to loop twice to create the files first than checking for file creation every time
	s deviceName="",deviceList=""
	while ('data.AtEnd){	
		set sectionLine = data.ReadLine()
		// Example
		// 11:24:10     dev65-64      3,50      0,00    110,51     31,54      
		s deviceName=$PIECE($ZSTRIP(sectionLine,"=W")," ",2)
		if (deviceName'="DEV") {
			set fileName = ##class(%File).NormalizeFilename(deviceName_".txt",directory)
			set fileStream(deviceName) = ##class(%Stream.FileCharacter).%New()
			set fileStream(deviceName).Filename=fileName
			do fileStream(deviceName).WriteLine(headerLine)
			do fileStream(deviceName).WriteLine(sectionLine)
			set deviceList=deviceList_","_deviceName
		
		} else { 
			// Save a device.txt file with a list of devices 
			set fileName = ##class(%File).NormalizeFilename("devices.txt",directory)
			set fileStreamDevices = ##class(%Stream.FileCharacter).%New()
			set fileStreamDevices.Filename=fileName
			do fileStreamDevices.WriteLine(deviceList)
			do fileStreamDevices.%Save()
			quit
		}
	}
	
	// loop to save data. 
	while ('data.AtEnd){	
		set sectionLine = data.ReadLine()
		s deviceName=$PIECE($ZSTRIP(sectionLine,"=W")," ",2)
		if (deviceName'="DEV") {
			do fileStream(deviceName).WriteLine(sectionLine)
		}
	}
	
	// Save files
	s dn=""
	for  {
     set dn=$ORDER(fileStream(dn)) 
     quit:dn=""
     do fileStream(dn).%Save()
    }
	
	
	quit
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
//  ---------------------- parse Buttons functions  ----------------------

]]></Content>
</UDLText>

<Method name="parseHTMLButtons">
<Description>
main parse function to parse Buttons
</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pFile</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	
	set directory = pFile_".sections"
	set ret = $$$OK
	try {
		Set stream=##class(%Stream.FileCharacter).%New()
		$$$THROWONERROR(tSC, stream.LinkToFile(pFile))
		set sc=##class(%File).CreateDirectory(directory)
		if sc {
			do ..writeButtonsSectionsToFile(stream,directory)
		}else{
			write !,"ERROR:can't create directory "_directory_"\n"
		}
		
	} catch ex {
		set ret = ex.AsStatus()
		write !,"<ERROR> parseHTML: "_$system.Status.GetOneErrorText(ret)
	}
	quit ret
]]></Implementation>
</Method>

<Method name="writeButtonsSectionsToFile">
<ClassMethod>1</ClassMethod>
<FormalSpec>data:%Stream.FileCharacter,directory</FormalSpec>
<Implementation><![CDATA[
	set startSearch=1
	set listSections=""
	while ('data.AtEnd){
		// Sections like
		// <a name="general"></a>General</b></font>
		// <pre>
		// ..
		// </pre>

		set sectionPosition=data.FindAt(startSearch,"<a name=")
		quit:sectionPosition=-1 ; no more sections found
		
		set sc = data.MoveTo( sectionPosition )
		set sectionLine = data.ReadLine()
		set startSearch=sectionPosition+$L(sectionLine)
		
		// Parse section with format:
		//<a name="general"></a>General</b></font>
		set section = $P(sectionLine,"""",2) 
		
		//Sections like cstat are different :-( so I can't use " to split
		//<a name=cstat1></a>cstat Snapshot # 1</font></b>
		if (section="") {
			set section = $P($P(sectionLine,"=",2),">",1) 
		}
		
		// open file to write section
		set fileName = ##class(%File).NormalizeFilename(section_".txt",directory)
		Set fileStream = ##class(%Stream.FileCharacter).%New()
		set fileStream.Filename=fileName
		// <pre>
		// Read lines to start inside the <pre>
		//BREAK
		set prePosition=data.FindAt(startSearch,"<pre>")
		set sc = data.MoveTo( prePosition + $L("<pre>"))
		set line = data.ReadLine()
		set startSearch=sectionPosition+$L(line)
		
		while ( '$FIND(line,"</pre>") || data.AtEnd ){
			do fileStream.WriteLine(line)
			set line = data.ReadLine()
			set startSearch=startSearch+$L(line)
		}
		do fileStream.%Save()
		
		set listSections=listSections_","_section
		//set procesed = $NORMALIZE(startSearch*100/data.Size,2)
		//write !, "Section "_ section_" exported. Procesed: "_ procesed _"%"
		
	}
	
	// save the sections.txt file with a list of all the processed sections
	set fileName = ##class(%File).NormalizeFilename("sections.txt",directory)
	Set fileStream = ##class(%Stream.FileCharacter).%New()
	set fileStream.Filename=fileName
	do fileStream.WriteLine(listSections_",") //Added an empty line to parse easier 
	do fileStream.%Save()
	
	quit
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
//  ---------------------- generic functions  ----------------------

]]></Content>
</UDLText>

<Method name="unzipFile">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pFile]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	s noZipFile=$P(pFile,".ZIP",1)
	
	if ($LENGTH(noZipFile)<$LENGTH(pFile)){ //This is a zip file
		set cmd="unzip -o "_pFile_" -d "_##class(%File).GetDirectory(pFile)
		set sc=$ZF(-1,cmd)
		s pFile = noZipFile
		quit sc
	}
	quit $$$OK
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Library.CacheSerialState</Type>
<StreamLocation>^pButtons.UtilitiesS</StreamLocation>
</Storage>
</Class>
</Export>
